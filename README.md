## 1 概述

本次 `uELF` 是一次对 ELF 文件的尝试.

- 希望能够用足够精简的代码实现教学

- 希望通过该工具集能实现对 ELF 文件格式的各种解析.

目前暂时实现了一个加载器的功能.

[加载器文档](http://47.108.130.26:4000/2025/10/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%AF%87-%E6%89%8B%E5%86%99ELF%E5%8A%A0%E8%BD%BD%E5%99%A8/)

## 2 基本用法

```bash
# ./uelf --print <elf-file>
./uelf -p [-r|-s|-h|-p|-S|-m] <elf-file>
```

这对于调试或了解 ELF 文件结构非常有用.

## 3 加载与执行符号

若要将 `PT_LOAD` 段映射到内存并执行某个符号，可使用 `--load`（或 `-l`）选项：

```bash
./uelf --load <elf-file> [symbol]
```

- 当指定 `symbol` 时，工具会在符号表中查找该名称，并在非 PIE（ET_EXEC）二进制上调用它.
- 如果未指定 `symbol`，程序会默认查找并执行 `main` 函数.
- 对于非 PIE（ET_EXEC）可执行文件，加载器会解析 `.rela.dyn`/`.rela.plt` 并通过宿主进程的 `dlsym` 填充 GOT 与全局数据重定位，因此可正常调用 `printf`/`puts` 等外部符号.
- 如果重定位引用了弱符号（如 `_ITM_deregisterTMCloneTable`），在宿主未提供实现的情况下会保持空指针同时输出告警.
- 对于 PIE/共享库（ET_DYN），当前实现只完成段映射，不会直接执行符号以避免缺少重定位导致的错误.

示例：

```bash
./uelf --load test/main hello
```

加载流程会遍历所有 `SHT_RELA` 节并根据节头的 `sh_link` 找到对应的符号表，从而统一处理 `.rela.dyn`、`.rela.plt` 等重定位节.

- 对 `R_X86_64_RELATIVE` 类型，直接把 `addend` 加上装载基址写回目标位置，适用于绝对地址修正（例如 `.data` 区引用）.

- 对 `R_X86_64_GLOB_DAT` 以及 `R_X86_64_JUMP_SLOT` 类型，先通过静态/动态符号表获取名字，然后调用宿主进程的 `dlsym` 解析，最终回填到对应的 GOT 或 PLT/GOT 槽位中，因此无需显式解析 `.got`/`.plt` 节即可完成绑定.

- 对 `R_X86_64_64` 类型，会在解析出符号地址后叠加 `addend` 写回，覆盖函数指针等绝对引用.

需要注意：实现依赖节表提供的重定位信息；若目标二进制被完全剥离了节表（常见于生产环境的 SO），则当前代码无法从 `.dynamic` 中恢复 GOT/PLT 信息，这也是后续计划优化的方向.

该命令会加载 `test/main`，找到名为 `hello` 的符号并执行它.

## 4 查看帮助

```bash
./uelf --help
```

会打印简要的命令行参数说明.

## 5 清理

```bash
make clean
```

会删除构建产物.